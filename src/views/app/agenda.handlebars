<div class="all">
    <div class="modal-overlay" id="send-proposal-modal-overlay">
        <div class="modal-send-proposal" id="send-proposal-modal">
            <div class="modal-header">
                <h2>Enviar Proposta de Serviço</h2>
                <button class="modal-close-btn" id="close-send-proposal-modal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="send-proposal-form">
                    <div class="form-group">
                        <label for="proposal-title">Título da Proposta:</label>
                        <input type="text" id="proposal-title" required>
                    </div>
                    <div class="form-group">
                        <label for="proposal-description">Descrição:</label>
                        <textarea id="proposal-description" rows="4"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="proposal-date">Data:</label>
                        <input type="date" id="proposal-date" required>
                    </div>
                    <div class="form-group">
                        <label for="proposal-start-time">Hora Início:</label>
                        <input type="time" id="proposal-start-time" required>
                    </div>
                    <div class="form-group">
                        <label for="proposal-end-time">Hora Fim:</label>
                        <input type="time" id="proposal-end-time" required>
                    </div>
                    <div class="form-group">
                        <label for="proposal-price">Preço:</label>
                        <input type="number" id="proposal-price" step="0.01" min="0" required>
                    </div>
                    <div class="form-group">
                        <label for="proposal-tags">Tags (Categorias):</label>
                        <select id="proposal-tags" class="form-control" multiple="multiple" style="width: 100%;">
                        </select>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" type="submit" form="send-proposal-form">Enviar</button>
                <button class="btn btn-cancel" id="cancel-send-proposal-modal">Cancelar</button>
            </div>
        </div>
    </div>

    <div class="container-agenda">
        <div class="column">
            <div class="column-header-container">
                <h2 class="column-header-title">Serviços Agendados</h2> <button class="btn btn-primary"
                    id="send-proposal-btn">Enviar Proposta</button>
            </div>
            <ul class="card-list" id="scheduled-services-list">
                {{#each services}}
                <li class="card scheduled-service-card " data-id="{{id}}">
                    <h4>{{name}}</h4>
                    <p>{{establishment}}</p>
                    <p>{{local}}</p>
                    <p class="card-price">Preço: R$&nbsp;{{price}}</p>
                    <div class="card-meta">
                        <span>Data: {{date}}</span>
                        <span>Horário: {{startTime}} - {{endTime}}</span>
                    </div>
                </li>
                {{/each}}
            </ul>
        </div>

        {{#if isOwner}}
        <div class="column">
            <h2 class="column-header">Anotações do Serviço</h2>
            <div class="notes-area">
                <p id="no-service-selected">Selecione um serviço agendado para ver/editar anotações.</p>
                <label for="service-notes" style="display: none;">Anotações:</label>
                <textarea id="service-notes" placeholder="Digite suas anotações aqui..."
                    style="display: none;"></textarea>
                <div class="btn-container" style="display: none;">
                    <button class="btn btn-primary" id="save-notes-btn">Salvar Anotações</button>
                </div>
            </div>
        </div>
        {{/if}}

        {{#if isOwner}}
        <div class="column">
            <h2 class="column-header">Propostas Recebidas</h2>
            <ul class="card-list" id="received-proposals-list">
                {{#each serviceProposal}}
                <li class="card received-proposal-card" data-id="p1" data-type="pending">
                    <h4>{{name}}</h4>
                    <p>{{establishment}}</p>
                    <p>{{local}}</p>
                    <p class="card-price">Preço: R$&nbsp;{{price}}</p>
                    <div class="card-meta">
                        <span>Data: {{date}}</span>
                        <span>Horário: {{startTime}} - {{endTime}}</span>
                    </div>
                    <div class="card-actions">
                        <button class="btn btn-success proposal-action-btn" data-action="accept"
                            data-proposal-id="p1">Aceitar</button>
                        <button class="btn btn-danger proposal-action-btn" data-action="reject"
                            data-proposal-id="p1">Recusar</button>
                    </div>
                </li>
                {{/each}}
            </ul>
        </div>
        {{/if}}
    </div>
</div>

<div class="modal-overlay" id="proposal-view-modal-overlay">
    <div class="modal-view" id="proposal-view-modal">
    </div>
</div>

<style>
    .card-status {
        margin-top: 10px;
        text-align: center;
    }

    .status-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.9em;
        font-weight: bold;
    }

    .status-badge.accepted {
        background-color: #28a745;
        color: white;
    }

    .status-badge.rejected {
        background-color: #dc3545;
        color: white;
    }

    .received-proposal-card.accepted {
        border-left: 4px solid #28a745;
    }

    .received-proposal-card.rejected {
        border-left: 4px solid #dc3545;
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', () =>
    {
        // === Referências aos elementos DOM ===
        const scheduledServicesList = document.getElementById('scheduled-services-list');
        const receivedProposalsList = document.getElementById('received-proposals-list');
        const serviceNotesTextarea = document.getElementById('service-notes');
        const saveNotesBtn = document.getElementById('save-notes-btn');
        const noServiceSelectedMessage = document.getElementById('no-service-selected');
        const notesLabel = document.querySelector('.notes-area label');
        const notesBtnContainer = document.querySelector('.notes-area .btn-container');

        // Referências para o modal de visualização de proposta/serviço
        const proposalViewModalOverlay = document.getElementById('proposal-view-modal-overlay');
        const proposalViewModal = document.getElementById('proposal-view-modal');

        // Referências para o modal de envio de proposta
        const sendProposalBtn = document.getElementById('send-proposal-btn');
        const sendProposalModalOverlay = document.getElementById('send-proposal-modal-overlay');
        const sendProposalModal = document.getElementById('send-proposal-modal');
        const closeSendProposalModalBtn = document.getElementById('close-send-proposal-modal');
        const cancelSendProposalModalBtn = document.getElementById('cancel-send-proposal-modal');
        const sendProposalForm = document.getElementById('send-proposal-form');
        const proposalTagsSelect = document.getElementById('proposal-tags'); // Novo campo Select2

        const id = {{userid}};
        const isOwner = {{isOwner}};

        // Variável para controlar qual serviço agendado está selecionado para anotações
        let currentSelectedServiceId = null;

        // === Dados Locais (Serão populados pelas chamadas fetch) ===
        let scheduledServices = [];
        let receivedProposals = [];
        // Tags disponíveis para o Select2 (em um cenário real, viriam do backend)
        let availableTags = [
            { id: 'musica', text: 'Música' },
            { id: 'evento', text: 'Evento' },
            { id: 'aula', text: 'Aula' },
            { id: 'gravacao', text: 'Gravação' },
            { id: 'show', text: 'Show' },
            { id: 'ensaio', text: 'Ensaio' },
            { id: 'outros', text: 'Outros' }
        ];

        // === Funções Auxiliares ===

        const resetNotesArea = () =>
        {
            serviceNotesTextarea.value = '';
            noServiceSelectedMessage.style.display = 'block';
            notesLabel.style.display = 'none';
            serviceNotesTextarea.style.display = 'none';
            notesBtnContainer.style.display = 'none';
            // Remove a classe 'active' de todos os cards de serviço agendado
            document.querySelectorAll('#scheduled-services-list .card.active').forEach(c => c.classList.remove('active'));
            currentSelectedServiceId = null; // Zera o ID do serviço selecionado
        };

        document.addEventListener('click', (e) =>
        {
            const clickedCard = e.target.closest('.scheduled-service-card');
            const clickedNotesArea = e.target.closest('.notes-area'); // Pega o elemento pai .notes-area
            const clickedModal = e.target.closest('.modal-overlay'); // Pega o modal (overlay ou o modal em si)

            // Se clicou em um card de serviço agendado, ou na área de anotações, ou em um modal,
            // não faz nada para desativar. A ativação/visualização será tratada pelos listeners específicos.
            if (clickedCard || clickedNotesArea || clickedModal)
            {
                return;
            }

            // Se nenhum dos acima foi clicado, redefine a área de anotações
            resetNotesArea();
        });

        // Formata o preço para moeda local
        const formatPrice = (price) =>
        {
            return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(price);
        };

        // Aplica o scroll à lista de cards se houver mais de 4 itens
        const applyScrollToCardList = (listElement, cardCount) =>
        {
            const singleCardHeight = 160; // Altura aproximada de um card, ajuste se necessário
            const maxHeightForFourCards = singleCardHeight * 4;

            if (cardCount > 4)
            {
                listElement.style.maxHeight = `${ maxHeightForFourCards }px`;
                listElement.style.overflowY = 'auto';
            } else
            {
                listElement.style.maxHeight = 'none';
                listElement.style.overflowY = 'visible';
            }
        };

        // === Funções de Renderização ===

        // Carrega e renderiza os cards de serviços agendados
        const loadAndRenderScheduledServices = async () =>
        {
            try
            {
                const response = await fetch(`/agenda/servicos/${ id }`)
                const data = await response.json();
                //console.log(data);

                scheduledServices = data.services;
                scheduledServicesList.innerHTML = '';
                scheduledServices.forEach(service =>
                {
                    const li = document.createElement('li');
                    li.className = `card scheduled-service-card ${ service.id === currentSelectedServiceId ? 'active' : '' }`;
                    li.dataset.id = service.id;
                    li.innerHTML = `
                    <h4>${ service.name }</h4>
                    <p>Cliente: ${ service.establishmentName }</p>
                    <p>Local: </p>
                    <p class="card-price">Preço: ${ formatPrice(service.price) }</p>
                    <div class="card-meta">
                        <span>Data: ${ service.date }</span>
                        <span>Horário: ${ service.startTime } - ${ service.endTime }</span>
                    </div>
                `;
                    scheduledServicesList.appendChild(li);
                });
                applyScrollToCardList(scheduledServicesList, scheduledServices.length);
            } catch (error)
            {
                console.error('Erro ao carregar serviços agendados:', error);
                alert('Erro ao carregar serviços agendados.');
            }
        };

        // Carrega e renderiza os cards de propostas recebidas
        const loadAndRenderReceivedProposals = async () =>
        {
            try
            {
                const response = await fetch(`/agenda/propostas/${ id }`)
                const data = await response.json();
                console.log(data);

                receivedProposals = data.received;
                receivedProposalsList.innerHTML = '';
                receivedProposals.forEach(proposal =>
                {
                    const li = document.createElement('li');
                    li.className = `card received-proposal-card ${ proposal.status }`;
                    li.dataset.id = proposal.id;
                    li.dataset.type = proposal.status;
                    li.innerHTML = `
                    <h4>${ proposal.name }</h4>
                    <p>Cliente: ${ proposal.client }</p>
                    <p>Tipo: ${ proposal.type }</p>
                    <p class="card-price">Preço: ${ formatPrice(proposal.price) }</p>
                    <div class="card-meta">
                        <span>Data: ${ proposal.date }</span>
                        <span>Horário: ${ proposal.startTime } - ${ proposal.endTime }</span>
                    </div>
                    ${ proposal.status === 'pending' ? `
                    <div class="card-actions">
                        <button class="btn btn-success proposal-action-btn" data-action="accept" data-proposal-id="${ proposal.id }">Aceitar</button>
                        <button class="btn btn-danger proposal-action-btn" data-action="reject" data-proposal-id="${ proposal.id }">Recusar</button>
                    </div>
                    ` : `
                    <div class="card-status">
                        <span class="status-badge ${ proposal.status }">${ proposal.status === 'accepted' ? 'Aceita' : 'Recusada' }</span>
                    </div>
                    `}
                `;
                    receivedProposalsList.appendChild(li);
                });
                applyScrollToCardList(receivedProposalsList, receivedProposals.length);
            } catch (error)
            {
                console.error('Erro ao carregar propostas recebidas:', error);
                alert('Erro ao carregar propostas recebidas.');
            }
        };

        // === Funções de Gerenciamento de Modais ===

        // Abre o modal de visualização (proposta/serviço agendado)
        const openProposalViewModal = () =>
        {
            proposalViewModalOverlay.classList.add('active');
            proposalViewModal.classList.add('active');
        };

        // Fecha o modal de visualização
        const closeProposalViewModal = () =>
        {
            proposalViewModalOverlay.classList.remove('active');
            proposalViewModal.classList.remove('active');
        };

        // Configura e exibe o modal de visualização de proposta/serviço
        const setupViewProposalModal = (data, isPending = false) =>
        {
            let actionButtonsHtml = '';
            if (isPending)
            {
                actionButtonsHtml = `
                <button class="btn btn-success proposal-action-btn" data-action="accept" data-proposal-id="${ data.id }">Aceitar</button>
                <button class="btn btn-danger proposal-action-btn" data-action="reject" data-proposal-id="${ data.id }">Recusar</button>
            `;
            }

            proposalViewModal.innerHTML = `
            <div class="modal-header">
                <h2>${ data.name || 'Detalhes' }</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p><strong>Cliente:</strong> ${ data.client }</p>
                <p><strong>Tipo de Serviço:</strong> ${ data.type }</p>
                <p><strong>Data:</strong> ${ data.date }</p>
                <p><strong>Horário:</strong> ${ data.startTime } - ${ data.endTime }</p>
                ${ data.description ? `<p><strong>Descrição:</strong> ${ data.description }</p>` : '' }
                ${ data.notes ? `<p><strong>Anotações:</strong> ${ data.notes }</p>` : '' }
                <p class="modal-price"><strong>Preço:</strong> ${ formatPrice(data.price) }</p>
            </div>
            <div class="modal-footer">
                ${ actionButtonsHtml }
                <button class="btn btn-primary modal-close-btn">Fechar</button>
            </div>
        `;

            // Adicionar listeners para os botões de fechar dentro do modal
            proposalViewModal.querySelectorAll('.modal-close-btn').forEach(btn =>
            {
                btn.onclick = closeProposalViewModal;
            });

            // Adicionar listeners para os botões de ação (Aceitar/Recusar) dentro do modal
            if (isPending)
            {
                proposalViewModal.querySelectorAll('.proposal-action-btn').forEach(btn =>
                {
                    btn.onclick = (e) => handleProposalAction(e, data.id);
                });
            }

            openProposalViewModal();
        };

        // Abre o modal de envio de proposta
        const openSendProposalModal = () =>
        {
            sendProposalModalOverlay.classList.add('active');
            sendProposalModal.classList.add('active');
            // Inicializa/re-inicializa o Select2 ao abrir o modal
            // Certifique-se de que o jQuery e o Select2 estejam carregados antes deste ponto
            $(proposalTagsSelect).select2({
                placeholder: "Selecione as tags",
                data: availableTags, // Popula as opções com as tags disponíveis
                allowClear: true // Permite limpar a seleção
            });
        };

        // Fecha o modal de envio de proposta e limpa o formulário
        const closeSendProposalModal = () =>
        {
            sendProposalModalOverlay.classList.remove('active');
            sendProposalModal.classList.remove('active');
            sendProposalForm.reset(); // Limpa os campos do formulário
            // Limpa o Select2
            if ($(proposalTagsSelect).data('select2'))
            { // Verifica se Select2 foi inicializado
                $(proposalTagsSelect).val(null).trigger('change');
            }
        };

        // === Funções de Lógica de Negócio (Comentadas para Fetch) ===

        // Lida com a ação de aceitar ou recusar uma proposta via API
        const handleProposalAction = async (e, proposalId) =>
        {
            const action = e.target.dataset.action; // 'accept' ou 'reject'

            try
            {
                const response = await fetch(`/agenda/proposta/resposta/${ proposalId }`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: action })
                });

                if (!response.ok)
                {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Erro ao processar proposta');
                }

                const result = await response.json();
                alert(result.message || `Proposta ${ action === 'accept' ? 'aceita' : 'recusada' } com sucesso!`);

                // Re-renderizar as listas após a ação bem-sucedida
                await loadAndRenderScheduledServices();
                await loadAndRenderReceivedProposals();
                closeProposalViewModal(); // Fechar o modal de visualização após a ação

                // Resetar área de anotações se o serviço selecionado era uma proposta aceita
                if (action === 'accept' && currentSelectedServiceId === proposalId)
                {
                    serviceNotesTextarea.value = '';
                    noServiceSelectedMessage.style.display = 'block';
                    notesLabel.style.display = 'none';
                    serviceNotesTextarea.style.display = 'none';
                    notesBtnContainer.style.display = 'none';
                    currentSelectedServiceId = null;
                }

            } catch (error)
            {
                console.error(`Erro ao ${ action === 'accept' ? 'aceitar' : 'recusar' } proposta:`, error);
                alert(`Erro ao ${ action === 'accept' ? 'aceitar' : 'recusar' } proposta. Tente novamente.`);
            }
        };

        // Salva as anotações de um serviço agendado via API
        const saveServiceNotes = async () =>
        {
            if (!currentSelectedServiceId)
            {
                alert('Nenhum serviço selecionado para salvar anotações.');
                return;
            }

            try
            {
                const notes = serviceNotesTextarea.value;
                // === COLOQUE SEU FETCH REAL AQUI PARA ATUALIZAR ANOTAÇÕES ===
                // Exemplo:
                // const response = await fetch(`/api/services/${currentSelectedServiceId}/notes`, {
                //     method: 'PUT',
                //     headers: { 'Content-Type': 'application/json' },
                //     body: JSON.stringify({ notes: notes })
                // });
                //
                // if (!response.ok) {
                //     const errorData = await response.json();
                //     throw new Error(errorData.message || 'Erro ao salvar anotações');
                // }
                //
                // const result = await response.json();

                const response = await fetch(`/agenda/salvar-anotacao/${ currentSelectedServiceId }`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ notes: notes })
                    });

                const data = await response.json();
                alert(data.message); // Simulação de sucesso

                // Atualizar o dado no array local para consistência (sem re-renderizar tudo)
                console.log(currentSelectedServiceId);
                const serviceIndex = scheduledServices.findIndex(s => s.id === Number(currentSelectedServiceId));
                if (serviceIndex !== -1)
                {
                    scheduledServices[serviceIndex].notes = notes;
                }

            } catch (error)
            {
                console.error('Erro ao salvar anotações:', error);
                alert('Erro ao salvar anotações. Tente novamente.');
            }
        };


        // === Listeners de Eventos ===

        if (isOwner)
        {
            // Listener para clicar em serviços agendados (selecionar para anotações e abrir modal de visualização)
            scheduledServicesList.addEventListener('click', async (e) =>
            {
                const card = e.target.closest('.card');
                if (card && card.dataset.id)
                {
                    // Remove 'active' de todos os cards de agendados
                    document.querySelectorAll('#scheduled-services-list .card').forEach(c => c.classList.remove('active'));
                    // Adiciona 'active' ao card clicado
                    card.classList.add('active');

                    currentSelectedServiceId = card.dataset.id;
                    console.log(currentSelectedServiceId);
                    // Em um cenário real, você faria um fetch para obter os detalhes mais recentes do serviço:
                    // const response = await fetch(`/api/services/${currentSelectedServiceId}`);
                    // const service = await response.json();
                    // Para simulação, busca no array local:
                    console.log(scheduledServices)
                    const service = scheduledServices.find(s => s.id === Number(currentSelectedServiceId));
                    console.log(service)

                    if (service)
                    {
                        // Exibe a área de anotações
                        noServiceSelectedMessage.style.display = 'none';
                        notesLabel.style.display = 'block';
                        serviceNotesTextarea.style.display = 'block';
                        notesBtnContainer.style.display = 'block';
                        serviceNotesTextarea.value = service.notes || '';

                        // Abre o modal de visualização para o serviço agendado
                        //setupViewProposalModal(service, false);
                    }
                }
            });
        }

        // Listener para o botão Salvar Anotações
        if (saveNotesBtn)
        {
            saveNotesBtn.addEventListener('click', saveServiceNotes);
        }

        // Listener para clicar em propostas recebidas (abrir modal de visualização ou executar ação)
        if (receivedProposalsList)
        {
            receivedProposalsList.addEventListener('click', async (e) =>
            {
                const card = e.target.closest('.card');
                if (card && card.dataset.id)
                {
                    const proposalId = card.dataset.id;
                    const proposalStatus = card.dataset.type;

                    // Só permite ações se a proposta estiver pendente
                    if (proposalStatus !== 'pending')
                    {
                        return;
                    }

                    // Em um cenário real, você faria um fetch para obter os detalhes mais recentes da proposta:
                    // const response = await fetch(`/api/proposals/${proposalId}`);
                    // const proposal = await response.json();
                    // Para simulação, busca no array local:
                    const proposal = receivedProposals.find(p => p.id === Number(proposalId));

                    if (proposal)
                    {
                        const targetBtn = e.target.closest('.proposal-action-btn');
                        if (targetBtn)
                        {
                            handleProposalAction(e, proposalId);
                        } else
                        {
                            setupViewProposalModal(proposal, true);
                        }
                    }
                }
            });
        }

        // Listener para o botão "Enviar Proposta"
        if (sendProposalBtn)
        {
            sendProposalBtn.addEventListener('click', () =>
            {
                openSendProposalModal();
            });
        }

        // Listeners para fechar o modal de envio de proposta
        if (closeSendProposalModalBtn)
        {
            closeSendProposalModalBtn.addEventListener('click', closeSendProposalModal);
        }
        if (cancelSendProposalModalBtn)
        {
            cancelSendProposalModalBtn.addEventListener('click', closeSendProposalModal);
        }
        sendProposalModalOverlay.addEventListener('click', (e) =>
        {
            if (e.target === sendProposalModalOverlay)
            {
                closeSendProposalModal();
            }
        });

        // Listener para o envio do formulário de proposta
        if (sendProposalForm)
        {
            sendProposalForm.addEventListener('submit', async (e) =>
            {
                e.preventDefault();

                const title = document.getElementById('proposal-title').value;
                const description = document.getElementById('proposal-description').value;
                const date = document.getElementById('proposal-date').value;
                const startTime = document.getElementById('proposal-start-time').value;
                const endTime = document.getElementById('proposal-end-time').value;
                const price = parseFloat(document.getElementById('proposal-price').value);

                if (!title || !date || !startTime || !endTime || isNaN(price))
                {
                    alert('Por favor, preencha todos os campos obrigatórios (Título, Data, Hora Início, Hora Fim, Preço) e selecione ao menos uma tag.');
                    return;
                }

                try
                {
                    const response = await fetch('/agenda/enviar-proposta', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userid: id, // ID do usuário que receberá a proposta
                            name: title,
                            description: description,
                            date: date,
                            startTime: startTime,
                            endTime: endTime,
                            price: price.toString(),
                        })
                    });

                    if (!response.ok)
                    {
                        const errorData = await response.json();
                        throw new Error(errorData.message || 'Erro ao enviar proposta');
                    }

                    const result = await response.json();
                    alert(result.message || 'Proposta enviada com sucesso!');

                    // Fecha o modal e limpa o formulário
                    closeSendProposalModal();

                    // Recarrega as listas para mostrar a nova proposta
                    if (isOwner)
                    {
                        await loadAndRenderScheduledServices();
                        await loadAndRenderReceivedProposals();
                    }

                } catch (error)
                {
                    console.error('Erro ao enviar proposta:', error);
                    alert('Erro ao enviar proposta. Tente novamente.');
                }
            });
        }

        // === Inicialização ===

        // Carregar e renderizar as listas ao carregar a página
        loadAndRenderScheduledServices();

        if (isOwner)
        {
            loadAndRenderReceivedProposals();
        }

        // NOTA: A inicialização do Select2 para `proposalTagsSelect` é feita dentro de `openSendProposalModal`
        // para garantir que o elemento já esteja no DOM e pronto para ser inicializado.
        // Se `availableTags` precisasse ser carregado do backend, essa lógica deveria
        // vir antes da chamada a `openSendProposalModal`, provavelmente na inicialização.
        // Exemplo para carregar tags:
        /*
        async function loadAvailableTags() {
            try {
                const response = await fetch('/api/tags');
                const data = await response.json();
                availableTags = data.map(tag => ({ id: tag.id, text: tag.name })); // Assumindo {id, name}
            } catch (error) {
                console.error('Erro ao carregar tags disponíveis:', error);
                availableTags = []; // Garante que a lista não esteja nula
            }
        }
        loadAvailableTags(); // Chame esta função na inicialização se precisar carregar tags
        */
    });
</script>